/*
   This file was generated automatically by the Mojo IDE version B1.3.6.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module game_fsm_3 (
    input clk,
    input rst,
    input [31:0] ran,
    input [55:0] counter2,
    input [0:0] start,
    input [7:0] button,
    output reg [0:0] whetherstart,
    output reg [7:0] display,
    output reg out,
    output reg [127:0] s_seg_display,
    output reg [15:0] target_display
  );
  
  
  
  wire [16-1:0] M_alu_out;
  wire [1-1:0] M_alu_z;
  wire [1-1:0] M_alu_v;
  wire [1-1:0] M_alu_n;
  reg [16-1:0] M_alu_a;
  reg [16-1:0] M_alu_b;
  reg [6-1:0] M_alu_alufn;
  alu_4 alu (
    .a(M_alu_a),
    .b(M_alu_b),
    .alufn(M_alu_alufn),
    .out(M_alu_out),
    .z(M_alu_z),
    .v(M_alu_v),
    .n(M_alu_n)
  );
  
  wire [(4'h8+0)-1:0] M_edge_detector_out;
  reg [(4'h8+0)-1:0] M_edge_detector_in;
  
  genvar GEN_edge_detector0;
  generate
  for (GEN_edge_detector0=0;GEN_edge_detector0<4'h8;GEN_edge_detector0=GEN_edge_detector0+1) begin: edge_detector_gen_0
    edge_detector_5 edge_detector (
      .clk(clk),
      .in(M_edge_detector_in[GEN_edge_detector0*(1)+(1)-1-:(1)]),
      .out(M_edge_detector_out[GEN_edge_detector0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  wire [(4'h8+0)-1:0] M_button_cond_out;
  reg [(4'h8+0)-1:0] M_button_cond_in;
  
  genvar GEN_button_cond0;
  generate
  for (GEN_button_cond0=0;GEN_button_cond0<4'h8;GEN_button_cond0=GEN_button_cond0+1) begin: button_cond_gen_0
    button_conditioner_6 button_cond (
      .clk(clk),
      .in(M_button_cond_in[GEN_button_cond0*(1)+(1)-1-:(1)]),
      .out(M_button_cond_out[GEN_button_cond0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  localparam IDLE_state = 4'd0;
  localparam RANDOM_TARGET_state = 4'd1;
  localparam RANDOM_CARDS1_state = 4'd2;
  localparam RANDOM_CARDS2_state = 4'd3;
  localparam GAME11_state = 4'd4;
  localparam GAME12_state = 4'd5;
  localparam WIN_state = 4'd6;
  localparam LOSE_state = 4'd7;
  localparam COMP_state = 4'd8;
  
  reg [3:0] M_state_d, M_state_q = IDLE_state;
  reg [15:0] M_targetnumber_d, M_targetnumber_q = 1'h0;
  reg [0:0] M_opr_d, M_opr_q = 1'h0;
  reg [15:0] M_ra_d, M_ra_q = 1'h0;
  reg [15:0] M_rb_d, M_rb_q = 1'h0;
  reg [127:0] M_r_d, M_r_q = 1'h0;
  reg [5:0] M_alufn_d, M_alufn_q = 1'h0;
  reg M_numIncre_d, M_numIncre_q = 1'h0;
  reg [27:0] M_counter1_d, M_counter1_q = 1'h0;
  
  integer i;
  
  integer validity;
  
  always @* begin
    M_state_d = M_state_q;
    M_ra_d = M_ra_q;
    M_r_d = M_r_q;
    M_numIncre_d = M_numIncre_q;
    M_targetnumber_d = M_targetnumber_q;
    M_counter1_d = M_counter1_q;
    M_opr_d = M_opr_q;
    M_rb_d = M_rb_q;
    
    s_seg_display = 128'h00000000000000000000000000000000;
    target_display = M_targetnumber_q;
    for (i = 1'h0; i < 4'h8; i = i + 1) begin
      M_button_cond_in[(i)*1+0-:1] = button[(i)*1+0-:1];
    end
    for (i = 1'h0; i < 4'h8; i = i + 1) begin
      M_edge_detector_in[(i)*1+0-:1] = M_button_cond_out[(i)*1+0-:1];
    end
    if (start == 1'h1) begin
      M_counter1_d = M_counter1_q + 1'h1;
    end
    M_alu_a = 1'h0;
    M_alu_b = 1'h0;
    M_alu_alufn = 1'h0;
    out = 1'h0;
    display = 1'h0;
    whetherstart = start;
    
    case (M_state_q)
      IDLE_state: begin
        if (start == 1'h1) begin
          M_state_d = RANDOM_TARGET_state;
        end
      end
      RANDOM_TARGET_state: begin
        if (ran[4+0-:1] == 1'h0 && ran[0+3-:4] <= 4'hc && ran[0+3-:4] >= 3'h7) begin
          M_targetnumber_d = ran[0+3-:4];
          M_r_d = 128'h0fff0fff0fff0fff0fff0fff0fff0fff;
          M_numIncre_d = 1'h0;
          M_opr_d = 1'h1;
          M_state_d = RANDOM_CARDS1_state;
        end
        if (ran[4+0-:1] == 1'h1 && ran[0+3-:4] <= 3'h6 && ran[0+3-:4] >= 1'h0) begin
          M_targetnumber_d = ran[0+3-:4];
          M_r_d = 128'h0fff0fff0fff0fff0fff0fff0fff0fff;
          M_numIncre_d = 1'h0;
          M_opr_d = 1'h0;
          M_state_d = RANDOM_CARDS1_state;
        end
      end
      RANDOM_CARDS1_state: begin
        if (ran[0+3-:4] >= 1'h0 && ran[0+3-:4] <= 3'h7 && M_r_q[(ran[0+3-:4])*16+15-:16] == 12'hfff) begin
          M_r_d[(ran[0+3-:4])*16+15-:16] = M_numIncre_q;
        end
        M_numIncre_d = M_numIncre_q + 1'h1;
        if (M_numIncre_q > 2'h3) begin
          M_state_d = RANDOM_CARDS2_state;
        end
      end
      RANDOM_CARDS2_state: begin
        if (ran[0+3-:4] >= 1'h0 && ran[0+3-:4] <= 3'h7 && M_r_q[(ran[0+3-:4])*16+15-:16] == 12'hfff) begin
          if (M_opr_q == 1'h1) begin
            M_r_d[(ran[0+3-:4])*16+15-:16] = M_targetnumber_q - M_numIncre_q;
          end else begin
            M_r_d[(ran[0+3-:4])*16+15-:16] = M_targetnumber_q + M_numIncre_q;
          end
        end
        if (M_r_q[0+15-:16] != 12'hfff && M_r_q[16+15-:16] != 12'hfff && M_r_q[32+15-:16] != 12'hfff && M_r_q[48+15-:16] != 12'hfff && M_r_q[64+15-:16] != 12'hfff && M_r_q[80+15-:16] != 12'hfff && M_r_q[96+15-:16] != 12'hfff && M_r_q[112+15-:16] != 12'hfff) begin
          M_state_d = GAME11_state;
        end
      end
      GAME11_state: begin
        for (i = 1'h0; i < 4'h8; i = i + 1) begin
          if (M_edge_detector_out[(i)*1+0-:1] && M_r_q[(i)*16+15-:16] != 16'hffff) begin
            M_ra_d = i;
            M_state_d = GAME12_state;
          end
        end
        if (counter2[55+0-:1] == 1'h1) begin
          M_state_d = LOSE_state;
        end
      end
      GAME12_state: begin
        for (i = 1'h0; i < 4'h8; i = i + 1) begin
          if (M_edge_detector_out[(i)*1+0-:1] && M_r_q[(i)*16+15-:16] != 16'hffff && M_ra_q != i) begin
            M_rb_d = i;
            M_state_d = COMP_state;
            M_counter1_d = 1'h0;
          end
        end
        if (counter2[55+0-:1] == 1'h1) begin
          M_state_d = LOSE_state;
        end
      end
      COMP_state: begin
        M_alu_a = M_ra_q;
        M_alu_b = M_ra_q;
        M_alu_alufn = M_alufn_q;
        if (M_alu_out == M_targetnumber_q) begin
          M_r_d[(M_ra_q)*16+15-:16] = 16'hffff;
          M_r_d[(M_rb_q)*16+15-:16] = 16'hffff;
        end
        validity = 1'h1;
        for (i = 1'h0; i < 4'h8; i = i + 1) begin
          if (M_r_q[(i)*16+15-:16] != 16'hffff) begin
            validity = 1'h0;
          end
        end
        if (validity == 1'h1) begin
          M_state_d = WIN_state;
        end
        if (M_counter1_q[27+0-:1] == 1'h1) begin
          M_state_d = GAME11_state;
        end else begin
          s_seg_display[(M_ra_q)*16+15-:16] = M_r_q[(M_ra_q)*16+15-:16];
          s_seg_display[(M_rb_q)*16+15-:16] = M_r_q[(M_rb_q)*16+15-:16];
        end
      end
      WIN_state: begin
        display = 2'h3;
      end
      LOSE_state: begin
        display = 2'h1;
      end
      default: begin
        M_alu_a = 1'h0;
        M_alu_b = 1'h0;
        M_alu_alufn = 1'h0;
        M_state_d = IDLE_state;
        display = 1'h0;
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_targetnumber_q <= 1'h0;
      M_opr_q <= 1'h0;
      M_ra_q <= 1'h0;
      M_rb_q <= 1'h0;
      M_r_q <= 1'h0;
      M_alufn_q <= 1'h0;
      M_numIncre_q <= 1'h0;
      M_counter1_q <= 1'h0;
      M_state_q <= 1'h0;
    end else begin
      M_targetnumber_q <= M_targetnumber_d;
      M_opr_q <= M_opr_d;
      M_ra_q <= M_ra_d;
      M_rb_q <= M_rb_d;
      M_r_q <= M_r_d;
      M_alufn_q <= M_alufn_d;
      M_numIncre_q <= M_numIncre_d;
      M_counter1_q <= M_counter1_d;
      M_state_q <= M_state_d;
    end
  end
  
endmodule
