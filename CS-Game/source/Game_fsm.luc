module game_fsm (
    input clk,  // clock
    input rst,  // reset
    input ran[32],  // random number generator
    //input counter1[28],
    input counter2[56],
    input start[1],
    input button[8],
    //input r11[16],
    //input r12[16],
    output whetherstart[1],
    output display[8],
    output out,
    output s_seg_display[8][16], // display for seven segments of 8 card numbers
    output target_display[16] // display for seven segments of target nuber
  ) {
    alu alu;     //initializing alu
    
    //initializing states of fsm
    .clk(clk){
     edge_detector edge_detector[8](#RISE(1), #FALL(0));
     button_conditioner button_cond[8];
    
      .rst(rst) {
        fsm state = {IDLE,RANDOM_TARGET,RANDOM_CARDS1,RANDOM_CARDS2,GAME11,GAME12, WIN, LOSE, COMP };
        dff targetnumber[16];
        dff opr[1]; // 1 for add or 0 for substract
        dff ra[16];
        dff rb[16];
        dff r[8][16];
        dff numIncre;
        dff counter1[28]; // for display time count
    }
  }
  var i;
  var validity; //for checking pass purpose
  //always block
  always {
    s_seg_display = 8x{{16h0000}};
    target_display = targetnumber.q;
    
    
    for (i = 0; i<8; i++)
      button_cond.in[i] = button[i];
    for (i = 0; i<8; i++)
      edge_detector.in[i] = button_cond.out[i];
    
    if (start == 1)
      counter1.d = counter1.q + 1;
    
    alu.a = 0;
    alu.b = 0;
    out = 0;
    display = 0;
    whetherstart = start;
    
    
    //FSM main part
    case (state.q){
      
      //initial state
      state.IDLE:
        if (start == b1) 
         state.d = state.RANDOM_TARGET;
        
      
      state.RANDOM_TARGET:
        if (ran[4] == 0 && ran[3:0]<=12 && ran[3:0]>=7){
          targetnumber.d = ran[3:0];
          r.d = 8x{{h0fff}};
  
          numIncre.d = 0;
          opr.d = 1; // add operation
          state.d = state.RANDOM_CARDS1;
          }
        if (ran[4] == 1 && ran[3:0]<=6 && ran[3:0]>=0){
          targetnumber.d = ran[3:0];
          r.d = 8x{{h0fff}};
          numIncre.d = 0;
          opr.d = 0; // substract operation
          state.d = state.RANDOM_CARDS1;
          }
             
          
      state.RANDOM_CARDS1:
        if (ran[3:0]>=0 && ran[3:0]<=7 && r.q[ran[3:0]]==hfff)
          r.d[ran[3:0]] = numIncre.q;
          numIncre.d = numIncre.q + 1;
    
        if (numIncre.q>3)
          state.d = state.RANDOM_CARDS2;   
      
      state.RANDOM_CARDS2:
        if (ran[3:0]>=0 && ran[3:0]<=7 && r.q[ran[3:0]]==hfff){
          if (opr.q==1) // if addition, distribute targetnumber-numIncre to a random location
            r.d[ran[3:0]] = targetnumber.q-numIncre.q; 
          else          // if substraction, distribute targetnumber+numIncre to a random location 
            r.d[ran[3:0]] = targetnumber.q+numIncre.q;
        }  
        if (r.q[0]!=hfff && r.q[1]!=hfff && r.q[2]!=hfff && r.q[3]!=hfff && r.q[4]!=hfff 
          && r.q[5]!=hfff && r.q[6]!=hfff && r.q[7]!=hfff)
          state.d = state.GAME11;
 
      state.GAME11:
        for (i=0;i<8;i++)
          if (edge_detector.out[i] && r.q[i]!=hffff){
            ra.d = i;
            state.d = state.GAME12;
          }  
        
        if(counter2[55] == 1)
          state.d = state.LOSE;
      
            
      state.GAME12:
        for (i=0;i<8;i++)
          if (edge_detector.out[i] && r.q[i]!=hffff && ra.q!=i){
            rb.d = i;
            state.d = state.COMP;
            counter1.d = 0;
          }  
        if(counter2[55] == 1)
          state.d = state.LOSE;
      
      state.COMP:
        alu.a = ra.q;
        alu.b = ra.q;
        if (opr.q == 1) // add 
          alu.alufn = 0;
        else            // substract
          alu.alufn = 1;   
        
        if(alu.out == targetnumber.q){
          r.d[ra.q] = hffff;
          r.d[rb.q] = hffff;
        }      
        validity = 1;
        for (i=0;i<8;i++)
          if (r.q[i]!=hffff)
            validity = 0;
        if (validity == 1)
          state.d = state.WIN;
        if (counter1.q[27] == 1)
         state.d = state.GAME11;
        else{
         s_seg_display[ra.q] = r.q[ra.q];
         s_seg_display[rb.q] = r.q[rb.q];  
        }  

      state.WIN:
        display = b11;
        
      state.LOSE:
        display = b01;
          
      default:
        alu.a = 0;
        alu.b = 0;
        state.d = state.IDLE;
        display = b0; 
      }
  }
}
